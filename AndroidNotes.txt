TextView border

Делается через атрибут :background, куда устанавливается drawable shape (.xml)


Clear data / cache

Первый потрет файлы внутри типа data/data/files (картинки например)
А второе только темповые файлы


Файлы filesDir()

Persistent файлы - удаляются сами только при удалении приложения
Кэш это tmp файл (живут сколько указано в методах и тд)


Content provider

Ipc для обмена данными между изолированными процессами


Android resume

Под капотом Linux (process) + jvm (на каждое приложение)
Все работает на callbacks которые вызываются, когда юзер делает чтото с интерфейсом / девайсом
UI в xml
Есть внутренние механизмы для шаблонного взаимодействия типа contentprovider, broadcastreceiver, activities, intents, services
Если чтото переиспользовать то java наследование какого-то класса, или создание объекта требуемого класса


Data binding

Механизм, чтобы убрать findviewbyid
Используется viewModel
В grade добавлять надо


Material design

Смотрим так - XML: com.google.android.material.*


Storage

Есть getCacheDir() тот самый (оттуда удаляются файлы системой)
Есть просто getFileDir()
Есть бд sqlite
Есть assets (файлы внутри проекта типа)
Можно по сети качать
Есть preferences key value
Есть external storage (это не только microSD, а большая часть внутренней памяти). На нее нужен доступ


Adb moments:

Terminal: adb devices (выдаст номер девайса)
adb -s Номер shell
adb shell
Позволит коннектится к телефону и выполнять команды. Смотреть директории как на линухе ls. Но su без рута не сделать, поэтому много что ограничено


TextView hint

Можно сделать атрибут hint вместо default text удобно


GPS location

Делается либо через LocationManager()
Запрос прав
Периодическое обновление
Проброс юзера на окно включения gps
Либо play api


Permissions

Проверка наличия прав checkPermission()
Запрос прав requestPermission()
Обработка получения ввода юзера onRequestPermissionResult


Выравн элтов:

Надо вручную align между ними поставлять, иначе разъезжаются
Делать через align


TextView Selectable

В XML такой параметр нужно задать, чтобы данные можно было копировать из нее


Данные Android:

Internal/external storage
Key value storage (preferences)
SqLite db


Утечка памяти Android

Нюанс когда память не успевает очищаться, чтото её держит, когда она не нужна
Статик views не стоит делать, и еще рекомендации


TextView scrollable:

Оборачивается ScrollView. Вроде только один дочерний tw должен содержать.
После этого последний станет листаемым, если текст больше его размеров


Implicit intents

Action_sent можно юзать для обработки действия share
Можно сеттить вкладку открываемую в viewPager


Строки ресурсы в приложении

getResources().getString(R.string.btn_send)


Убрать view с экрана

progress at.setVisibility(invisible)
А если залочить нажимание, то setEnabled(false)


Куча

Отдельная структура данных (еще есть способ организации памяти такой, это другое), типа дерева, где максимум в корне, и она позволяет быстро доставать элемент с макс приоритетом
Делается на priorityQueue


Поменять состояние кнопки:

Так и не удалось setPressed() сделать из clickListenera другого


Toast не из UI

Надо делать workaround с getMainExecutor()


WorkManager

Лучше, чем JobSheduler, под собой содержит AlarmManager
Можно легко периодические задачи устанавливать


Drop down list

Назыв Spinner , можно ему ресурс в атрибут entries добавить, и значения будут протянуты из ресурсов строк, даже кода не понадобится


Пользование системных штук:

Context.getSystemService()
Тут и AlarmService
И Vibrator


Fragment listener

Нюанс - В onCreateView обязательно возвращать наш элемент view, а не super.blabla


BroadcastReceiver

Сущность для приёма интентов
Не забыть добавить в манифест
Используется для implicit intents, для чего в манифесте intent fliters задаются, а при отправке тип action интент устанавливается. Потом событие перезватывается всеми компонентами разных приложений, которые поддерживают данное действие
Может быть ещё explicit intent перехватываться


Notifications

Довольно просто делается через билдер и manager
Можно повесить обработку нажатия


AlarmManager

Точное время срабатывания событий, делается через pendingIntent и спец класс broadcastReceiver


Annotations

Не включаются при создании методов куча еболы типа @non null etc..


Layouts fragment

Если делать через создать fragment alt ins, то идея создаст его с говеным frameLayout, а нам нужен constraintLayout
Поэтому фрагменты руками создаём


BottomNavigationView

Меню снизу. Делается в конструкторе, клик листенер, атрибуты , отдельный xml на пункт меню. Selector на красивый выбор пункта меню
А вот переход между страницами реализуется через фрагменты


Toolbar

Toolbar это как actionBar (который системный сверху активити). Он же app bar
Menu это три точки справа сверху (overflow menu)
Ещё есть navigation bar снизу
И слева меню navigation drawer view гамбургер
Вкладки страниц


Планировщик задач

TimerTask java
SheduledExecutor java
======
SyncAdapter
Handler postAttime(), postDelayed()
AlarmManager, точный
JobSheduler, эффективный, но не точный
Самый актуальный WorkManager как я понял


Looper handler

Делаем задачи в отдельном потоке, Хуярим мессаджи в очередь, в хэндлере обрабатываем сообщения
Looper один для одного потока, реализует механизм очереди сообщений
Handler имеет связь с ui потоком, в нем обрабатываем views в зависимости от сообщений из worker тредов
Worker треды используют ссылку на handler
Типа тред не погибает при выполнении одной задачи, а живёт и ждёт
У каждого потока свой handler


Aidl binder

Какойто низкоуровневый интерфейс для взаимодействия компонентов в ос


IntentSevice

Типа сервис в отдельном потоке (одном фоновом)


Service & Thread

Первый может жить в фоне после закрытия приложения самого, но в ui потоке
Вторые закончатся как только приложение закроется, без фона, но потоки отдельные


Растяжение элементов

Если границы дочерних элементов неправильные, надо проверить родителя, и чтобы он был переменной ширины в виджете. Тогда все будет ок
Ну и позиционирование элементов один фиксируем жёстко слева например, а второй переменно крепим к первому. Тогда при повороте экрана все будет ровно
И ещё, все элементы нужно ровнять margina'ми, а не курсором.
Везде где можно match parent делать, и переменную ширину автозаполняющую


Установка одного атрибута дважды:

Обход проблемы в XML
Делается родительский контейнер, в нем свойство одного типа background цвет, а во внутреннем уже selectableitem при нажатии


Списки

Вообще по старому простые строковые делаются через arrayadapter
Если посложнее с картинками через baseadapter (getView)
Но по нормальному через recyclerview, уже с viewholder
Ещё одна оптимизация - метод на вью recyclerview hasfixedsize(true)


Стили res/layout

Если нужны не стандартные, то надо создавать xml с разметкой, и подтягивать в коде


Выровнять textview

Текст внутри элта по центру - атрибут gravity:center


Paddding/margin

Margin между элементами
Padding внутри


ViewHolder pattern

Inflater
Костыль для списков, чтобы не лагали, делается внутренним классом, хранит ссылки на textview/imageview, etc, так findviewbyid тяжеловесная операция
В recyclerview проще делается. В listview через gettag/settag


RecyclerView

Погружаются например 10 элементов из 100 в списке
Прокручиваем список, новые обьекты view создаются. Чтобы уменьшить расход памяти, часть первых элтов, которые уйдут из области видимости будут помечены dirty.
Потом когда прокручиваем, переиспользуются view. Типа данные просто заменяются, а обслуживает всего 13 views например, для 10 список.


Списки android

Есть adapterView(listView, GeidView etc), adapter
Есть recyclerView
Типа данные для отображения, список отображения listView и адаптер между ними


Okhttp

Синхронный вызов, в отдельном потоке делаем
Асинхронный сам в отдельном потоке делается


Если вылетает активити

Соддаем . java активити и xml ник, проверяем, что связь между ними выставлена в onCreate и xml нике.
Не забываем добавлять в манифест активити
Теги смотрим в xml
Ну и https/http резолвить руками надо если что при работе с сетью.


Builder pattern

Характерно создание объектов new Person.Builder()
.withName()
.withWeight()
Etc
Типа билдер класс вложен в наш основной, поэтому так. Юзается для удобства


Либы в android studio

Легко ставятся, просто в gradle dependencies тура строчку (из мавена можно)
Ну или через меню проектов


JSON andorid

Либо вручную через JsonObject (из коробки)
Либо GSON либа. Как Jackson примерно


Сеть android

Нужно делать в манифесте перимишн на сеть
Apache httpclient но это deprecated типа
Raw: httpUrlConnection (в jr похожее делали, загружая файл с urlа), либо Socket
Libs: okhttp, (retrofit)


Permissions

Dangerous нужен диалог с подтверждением пользователя. В runtime приложения
Usual автоматом даются
Если прав нет то будет securityException
Бывают к системным ресурсам, а бывают собственные пермишны для своих компонентов/других приложений


RxJava

Для stream обработки данных


Landscape

Поворачиваешь экран, тупо все коды заново отрабатывают onCreate и прочие
При открытии новой активити, и возврате к старой она начинает с начала onCreate все


Потоки Android

Можно как в java все 3 способа
Самый трушный инструмент Handler, но гемор
AsyncTask. Грязный код, не рекомендуется
=======
Looper есть сущность, MessageQueue
Отрисовывать UI только из UI main треда
View.post(runnable) на ui треде. Так из бэка можно на main передать результат
Activity.runOnUiThread(runnable) тоже как пост
Ещё есть Service но он не отдельный поток все равно. Просто невидимая операция. Но не долгая
Ещё IntentService (это с отдельным потоком)


Localization

Зависит от языка девайса
Для этого создаются отдельные папки res/values-fr/strings.xml, под каждую локаль


Android system

По сути линух
Каждое приложение это отдельный процесс, отдельный юзер, отдельная jvm, отдельные права на диск
Каждое приложение свой отдельный раздел памяти
Пользовательские разрешение


SaveInstanceState

Сохранение легковесное содержимого активити в map
Делается переменная константа STATE = "playerState"
И потом сохраняется saveInsState.putInt(STATE, curState)
Типа key сохраняем в переменную такой подход
Он же используется для intent


UI

TextView текст label
EditText поле ввода
Button кнопка
Фрагмент типа подмножество активити


Layots

Есть night/day ui
Есть portrait/labdscape ui
Есть mobile/tablet ui


Создание других экранов

Делается не в onCreate в mainActivity, а отдельной функцией. Потом эта функция прокручивается к onClick какой нибудь кнопке.
В маин все интенты создаются и put
В вызываемой активити вытаскиваются get


Custom activity:

Делается через no activity. До этого было Empty activity


Start new activity

Или новый экран, делается через интенты


Обработка кнопки:

Можно руками листенер делать, а можно сделать сначала заглушку метода, а потом в атрибутах (в дизайне) кнопки поставить в onClick созданный метод


Diff size верстка:

Надо делать так, чтобы элемент занимал асе свободное простанство. Это достигается за счет match constraint и группировки компонентов horizontal chain'омй
Ещё можно элементы относительно не краев, а других элементов


Strings android

Нужно не хардкодить строки в параметрах элементов, а выносить в res strings. Там они будут классно лежать, и по ссылке можно будет их юзать
Это можно сделать в строках > translation editor


Окна в приложениях

Это классы активити
Хотим открыть из одного другое, толкаем интент с нужным классом активити, и стартуем его


Intent

Это какая то абстрактная операция, которую надо осуществить


Потоки

Все действия в ui потоки делать отдельно, в background. Не в методах lifecycle activity


Activity data restore

1mb max bundle size
Тяжёлое в бд, а лёгкое можно


Activity lifecycle

При нажатии домой, состояние сохраняется, послет возврата (foreground) данные на месте должны быть (в память, из памяти)
onResume()/onPause()
При назад много раз, backstack приложения очищается и оно закрывается, состояние не сохраняется (сохранять на диск)
OnStop()
Также может закрыться если приложение в background (не на экране) и не хватает памяти


Android nuance

Все асинхронное, на коллбеках
Мы лишь говорим, чтобы чтото запустилось, а не запускаем


Эмулятор/Реал девайс:

Надо относительно экрана все выравнивать симметрично, слева справа, сверху, снизу. А не в 2х осях. Иначе съезжает на девайсе с другим экраном


Положение view

Чтобы закреплялись, нужно делать constraint со всех 4 сторон кружочком
Иначе только в дизайне будет ровно, а в рантайме криво


Android studio shortcuts:

все как в идее +
Alt + shift + left/right вкладки design, code


Переносимость

Работает на любом девайсе с min sdk прописанным, и на target
Все элты должны относительно поставлены быть


Density pixel (dp)

Ppi= sqrt(wid^2 + hei^2)/diag, а можно тупа длину в пискелах по горизонтали поделить на длину экрана в дюймах и получить примерное значение(по ширине примерно такое же будет)
100px!=100dp
Виртуальный пиксель для среднеплотных экранов (160dp). На ноуте 100ppi, херовый экран
На низкоплотном экране картинка уедет, станет огромной, эту пробл как раз решает dp
Dpi dots per inch
Ppi pixels per inch
Px = dp * (dpi / 160)
Говорим 16dp подразумеваем, что на таком стандартном экране длина определённая будет (пр.16 пикселов - 2.5мм). Для каждого нового экрана нужен будет пересчёт с учётом его плотности пикселей.есть пример в доках, см density. Для высоких разрешений он там захардкожен типа 0.75, 1, 1.5, 2
Экраны 2340х1080 высота на ширину


Aos

View это сущности типа текстового поля, картинки и тд. Могут быть сгруппированы в ViewGroup (пр. Layout, ConstrLayout)
Каждому экрану приложения свой activity класс с логикой + свой activity xmlник. На каждый xmlник свои layouts вставляются, в них - views
Локализации делаются через strings класс


Apk build

Build > build apk
Bundle типа apk для публикаций
Ещё можно apk analyze чето посмотреть там декомпилировать сорс


ADB

adb logcat
adb shell (можно как в линксе файловую систему дрочить, но нужен рут на мобиле)
adb push/pull
run-as com.domain.app перейти в директорию (data) с приложением
adb shell monkey -p com.ex.app -c android.intent.category.LAUNCHER 1 запуск приложения из консоли


Android studio

Простой hello world заработал, так ахуенно! Надо чтобы был включён debug mode на девайсе.
Можно на эмуляторе тестить, а можно на реальном.
На последнем, из IDE устанавливается приложение на устройство, запускается, и останавливается. Также какие то логи пишутся в консоль


Android

Manifest.xml структура
MainActivity.java логика экрана
activity_main.xml интерфейс экрана (макета, layout)
Приложение состоит из Activity классов-экранов
View это XML ники


Callbacks

Код который вызывается асинхронно, когда будет получен результат. Некий объект который будет вызван, когда функция в другом потоке отработает.
Коллбеки от системы при создании компонентов, не напрямую вызываем, а события от ОС.
Позволяют быть уверенными, что опр код не начнёт исполнение до того момента, пока другой код не завершит исполнение
Пример с JS там одна функция начинала выполнятстся раньше той, что была выше её в коде, но времяемкая


Xml

Если в тегах есть вложенные теги другие, то первый должен быть парным <...> абс </...>
Если нет, то может быть непарным < ... />
