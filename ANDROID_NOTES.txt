Recoursively open/close dirs

Держим стрелку влево или вправо зажатой долго


MVI android

Надстройка над mvvm
Actions States основные новые определения (маппинг одних на другие)
По сути задает states для активити/фрагмента, появляется доп метод в viewmodel
sealed class Actions {
object ViewInitialized: Actions()
object ButtonClicked: Actions()
}
Это обрабатывается в onAction(action) {
when(action) {
MainAction.ViewInitialized -> loading.set(true)
... fetchMessages()
} }
Далее в активити мы не просто дергаем метод вьюмодели, а указываем, что хотим сделать типа:
vm.OnAction(Actions.ButtonClicked)
Observe лайвдату так же
Для снижения неопределенности состояний.
Разделение viewmodel на состояния state
Sealed class MainState() {
object Loading: MainSate()
object Error: ...
class Data(val message: String): MainState()
}
И state: Observable<MainState>. После чего можно удалить livedata с прогрессом, данными и ошибкой
В активити снова when появляется на обработку стейтов
Кароче добавляет порядка этот подход при работе с livedata (или observable)
Типа во вьюмодели больше не сырые данные толкаем, а потомков MainState
Это типа redux только для андроид
StateMachine (далее Redux)
Но при смене состояний может потеряться инфа, для этого нужен reducer, и side effeft


Recycler callbacks

Есть onScrollStateChanged()
Есть onScrolled()
Можно подписаться на эти события и выполнять какие то полезные действия (момент с тултипом)


Figma moment

Есть классная кнопка +, где parent component, она выделит целиком компонент, если нажать только на дочерний, там будет описание его


Android studio git nickname

Задается через скрытый файл ~/.gitConfig, там параметр указать нужно с ником
Осмотреть можно через git config.username


Charles setup

По мануалу Юлы

1. Настроить сертификат в keychain (always trust)

2. На эмуляторе не работал интернет - на хост macOs настроить OpenDns в настройках wifi (девайс должен быть подключен к той же сети, что и сниффер, для эмулятора это выполняется само по себе)

3. В Proxy Settings > macOs выключаем чекбокс Enable MacOs Proxy - чтобы не захламлять вывод соединениями с мака

4. Надо прописать, что сниффим ssl трафик явно в настройках Proxy > SSL Proxy Settings > добавляем путь * в include, нажимаем чекбокс enabled

5. В настройках сети эмулятора нужно указать proxy - ip адрес нашего хост мака (берется из Help > Local IP address)

6. Теперь нужно на девайс серт charles ssl скачать: chls.pro/ssl - это отработает только если все шаги ранее правильны, произойдет запрос пермишена в charles'e, даем добро

7. Ставим серт на девайсе через раздел CA cert (!) в настройках, profit

8. Все, теперь можно сниффеть траф (в некоторых приложениях должно быть в манифесте добро на проксирование трафика)

9. Подмена трафика, простейший кейс - создаем json в папке в сторонке, далее пкм на интересующий нас запрос во вкладке sequence > map local >далее указать путь к json для подмены

возможно, но неточно: после ребута эмулятора нужно делать каждый раз установку сертификата
кароче надо чтобы соединение wifi на девайсе было без ! знака - помогло OpenDns на хост маке прописать в настройках wifi

Charles proxy

Кароче есть такой механизм, пожволяет не только смотреть запросы, но и их подменять
Настраивается с ебанием довольно таки, а так штука удобная


Лаги студии

Если студия залагивает так, что R.id файлы красные, то помогает restart and invalidate caches


PageObject

Не зная этого попробовал его, это тот самый класс Screen в ui тестах. Это паттерн
Типа как для класса есть его unit test class, так и для ui теста, его сценария, есть Screen class. Позволяет переиспользовать в разных тестах без дублирования


Стат анализ кода

Lint встроенный в agp. Слабая штука
Detekt (kt only). Тут больше проверок логики, а не только синтаксиса (у нас такой на ci в прошлом проекте было). И в текущем тоже.
SonarLint норм тема, похожа на detekt, плагин
SonarCube параша вроде, на серваке ci


Ui тесты

Kaspresso
Kakao Kautomator
PageObject - наш Screen класс с id views, находит и открывает наружу как проперти
Сам тест содержит steps() preconditions() и использует Screen который ранее задали, и юзает его вьюхи
Rules так же используются (это про то, как открыть экран в тесте)
Scenarios (это например повторяющиеся шаги, типа


Test suggestions

Зависимости (viewmodel) например юзать не конструкторы, а factory method
Кучу текстовых состояний не прямо в converter пихать лучше, а в sealed class отдельнл вынести с static методами
Date time в тестах лучше фейкать и цементировать


Зависимости и модуля в проекте

Как правило необходимо подцепить свою новую зависимость в общий граф dagger либо наоборот убрать
Тип свой подграф вставить в общий


Алгоритм поиска проблемы на ci

Отправляем код в репу
Падает в логах смотрим таску
Запускаем эту таску локально ./gradlew taskName
Далее ошибка будет более внятная


Test easy creation

Не руками тест создавать с директорией, а открыть класс для теста > лампочка попап, создать тест, и все само создаться


As Debug

Attach debugger to process это дебаг не с помощью перебилда долгого, а на лету типа
Не step into / over, а run to cursor юзаем, это то, что нам нужно как раз
Еще хорошая фича Evaluate expression, получить значение переменных до выполнения брейкпоинта
Layout inspector debug - смотрели вьюхи экрана их иерархию, потребовалось нажать на элемент снизу, чтобы все раскрылось само


Android Studio

Disable commit analyzing кнопка шестеренки ьам можно выключить, если зависает на проверке
Разделение табов на два экрана одновременно пкм по табу
Удаление новосозданного модуля тошько через finder
Убрать fix whitespace желтое уведомление: cmd option L


A/B тесты

Активно применяются в Авито в андроиде в том числе
Перед внедрением нового функционала исследование проходит, есть тестовая группа (новый функц) и контрол (старая), ну и делаются ветвления в коде, и динамическая проверка попадания юзера в группу тестовую (задаётся на беке), после чего смотрятся метрики как тест отработает. И в конце если все ок, тест внедряется, ну или заворачивается.


UI тесты

Они же инструментальные (гоняются на мобилке), ответы с бека мокированные
Есть еще e2e тесты, они на реальный бек запросы делают


Impact analysis

Крутая штука, позволяет не запускать проверки на файлы, которые не были задеты в билде
Configuration cache сюда же - механизм кэширования тасок в gradle, бывает локальный, remote. Сокращает воемя сборки, за счет переиспользования вычисл ресурсов


Backend driven ui

Основные бизнесовые процессы в компаниях сделаны на нем (чтото-пошаговое, переводы или подача объявления)


Андроид

Альмобная ориентация все таки используется на проектах, потрогать потом ее варианты создания


Открыть webView в отдельной активити

Делал сберовским компонентом прямо из кода, просто метод, принимающий строку с правилами акций
Само все загружалось


Андроид буфер обмена

Поработал с ним через обертку, но и наьив легко и хорошо работает, ClipboardManager класс
	

Дизайн система момент

Атрибуты надо брать, если они не deprecated, они зададут два цвета для компонента, без темы обойтись можно. Просто токен xml в background указать и все.
А я поябался и сделал свой токен с хардкодом цветов двух из дизайн системы, надёжный вариант


Геммороидальный момент с Room

В общем надо assets чтобы в правильном месте лежали. И прежде чем писать в бд, надо чтобы хоть одна операция по открытию соединения была.
Те записали в бд, проверили в device file explorer, далее любая crud операция, обновили файл справа, далее выкачали и подсунули в ассетс


Hot cold источники Rx

Холодный эмитит данные если есть хотя бы один подписчик
Горячий всегда. Также получает только новые события


RxJava flatMap

Отличие от map() в том, что первый просито берет элемент и применяет к нему функцию и возвращает результат
Второй же возвращает одно или больше значений выходных для одного входного элемента


Sigsegv

Два повторных запроса были, изза spinnera, как пофиксил, так исчезло
И дело было в связке rooma и этого


DI android

Блять додавить эту хуйню - лучше hilt. Все сделал, кроме последнего проект 3 недели и был послан нахер. Даже до собеса блять не дошёл, пиздануться.


Json parse moment

Если структура ебаная, то проще захардкодить поля, чем выдрачивать их по структуре


SingleLiveEvent

Реально нужная штука для многофрагментных экранов с общей livedata, для error диалогов, чтобы не дублировались
Однако нет в sdk, надо самому складывать в проект


Инициализация спиннера с setSelection() вызывает дважды onItemClicked()

Пиздец ебатория. Костыль на SoF:
spinner.setSelection(0, false), нужно до листенера сеттить


Адаптеры списков и корневая активити

Порой не надо пробрасывать события из адаптера recycler в корневую активити, достаточно во вьюмодель событие кинуть и все.
ClickListener не надо, viewmodel в конструктор адаптера


Diffutil

Сам точечно обновит данные в тех элементах списка где надо, а notifyDatasetChanged() все триггернет на обновление, даже то, что не поменялось


Безопасность момент 4

Рутинг типа надо выявлять и менять поведение, иначе все пойдёт по пизде
Типа системные директории становятся доступными для записи. Также ряд параметров ос - build.prop etc, наличие бинарников su файлов


Безопасность момент 3

Flag_secure для активити, чтобы нельзя было сделать скрин и в списке недавних было скрыто
WebView может погрузить вредного дерьма. Надо валидировать урл, и выключать allowFileAccess и allowContentAccess, allowFileAccessFromURLs, allowUniversalAccessFromFileURLs
Надо юзать WebViewAssetLoader для безопасной подгрузки ресурсов и выключать javascipt где он не нужен
Можно сделать интерфейс для работы с java объектами из js, типа прослойку для работы с webView. Это небезопасно


Безопасность момент 2

Intent filters
Exported true, позволит запустить активити из другой например, или сервис по имени класса, опасно
Сюда надо пермишн вешать
Вложенные интенты опасны
Надо объявлять пермишены кастомные в манифесте для активити, broadcast receiver
ContentProvider для шаринга доступа к директориям для чтения/записи, также на пермишенах


Безопасность момент

Есть какая то среда frida, которая позволяет подменять значения переменных в рантайме
Для этого надо многое делать на сервере, и шифровать ключом (keystore) параметры
Adb дамп памяти процесса
Хранить данные в мутабельных типах, чтобы перезаписать ячейку в памяти после использования, а не создать новую как в случае с val
Шифрованная бд есть realm, а также EncryptedSharedPreferences


Защита системы паролем

Позволяет включить шифрование файлов и секретов "доп солью"


Fragment inside fragment

Кароче можно вкладывать, через getChildFragmentManager() и frameLayout() и интерфейс взаимодействия
Активити внутрь фрагмента нельзя


Network from background service

После ухода приложения в фон у него есть пару минут чтобы создать service, далее нельзя
Самое простое service + сетевой запрос на отдельном threade, с передачей инфы в сервис через intent. А обратно через broadcast receiver или handler/message или aidl
Вначале делали через IntentService [топ решение] (сейчас JobIntentService). Это thread отдельный. Обычный сервис в main потоке.
JobIntentService это тот же IntentService, но с приблудой накрученной от JobScheduler
Обход ограничений энергопотребления - через foregroundService
Ну а так Гугл склоняет всех к JobSheduler
Ещё есть уже класс VpnService для этого
Ещё для broadcast receiver есть ограничения
WorkManager обёртка над JobScheduler (юзал последний)


Application lifecycle

Create
Memory trim
Terminate


Small screen

Всегда проверять на маленьком эмуляторе, тк на моём экране все ок, а на эмуляторе картинка растянулась
ImageView scale осторожно с. FitCenter, centerInside никогда не подведут, впишутся. Остальные стрельнуть могут


Момент с livedata value

Не хорошо на пр подсветили брать значение из лд в активити
Соотв надо делать метод вм который будет сам создавать лайвдату-событие и перекладывать


Жц fragments

Тонкие моменты есть с fragment view lifecycle и самим инстансом fragment, последний живёт дольше
Кароче есть attach detach ветка, а есть onCreateView()/onDestroyView(), это внутренний цикл типа (при fm.replace()). При .add все последовательно методы запускаются


Свайп приложения вверх и жц активити

Убьетмее, вызовется onDestroy()


Волшебная команда android studio

Cmd opt L
Сделает optimize imports, indents, cleanup code


Косяки android

Утечка слушателей live data во фрагментах
Запуск viewmodel из onCreate
Ссылки на viewmodel из классов, которые могут пережить активити


Api vs implementation gradle

Это аннотации различают то как мы сможем получить зависимость, с нутрянкой (первый случай) или без. Также от этого зависит будет ли пересобирираться весь модуль при изменениях в либе. При первом да, при втором только либа компилится будет заново, а не все.
Транзитивнлсть это невная зависимость. Те мы получаем по api constraintLayout к примеру из implemetation('DesignSystemLib'), тк они экспозят этот лейаут как api constraintLayout
Implementation пакует зависимость в билд файл (compile classpath). Кароче в runtime time только зависимость будет доступна потребителям, а при api еще и в compile time


LayoutParams

Так в рантайме задавать параметры для viewgroup
Исключения в рантайме


Передача данных между фрагментами

Кароче классика это интерфейс между активити и фрагментом
Но можно сделать shared viewmodel, типа init вм сделать в хост активити, а observe уже во фрагменте, и все будет работать.
Так можно передавать события - одна вьюмодель на активити/фрагмент, значит, например при получении события продукта после нажатия на элемент списка, роутер подписанный на вм стартанет другой фрагмент
Можно сделать умный адаптер класс, который будет содержать вм и роутер
Роутер будет содержать контекст и запускать на нем всякие фрагмент манагеры


Прихожу к решению как делать чтото

Ищу аналогию по проекту, смотрю если встречаются подобные паттерны, значит ок


Recent apps

Скользкий момент
Свайп последнего таска приложения не обязательно остановит process. Даст сигнал, убъет пошлет activity onFinish(), но сервис продолжит жить например


Activity process android

Один процесс по дефолту для приложения, в нем живут потоки
Система может убивать, процесс целиком, с остановленными активити.
Далее когда юзер возвр к экрану, процесс стартует заново и активити самовосстанавливается из saved state


Min sdk, target sdk, compile

Мин понятно, версия ос ниже не установит наше прил, не позволит юзать api, которого ещё нет в мин версии
Target целевая на которую рассчитываем при разработке, может работать на более ранних или поздних. Пример с runtime permissions (23 появ), а на 22 можно их по старому запрашивать, и будет работать. Однако есть ограничение в сторе
Компайл тайм sdk никак не влияет на runtime поведение. Те изолировано от работы на девайсе. Все новые проверки и новый api будет доступен, но не будут влиять на работу на девайсе


View model surviving configChange

При создании viewmodel ей задается viewModelStoreOwner (активити например)
ViewModelStore класс который должен переживать смену конфигурации
ViewModelStoreOwner хранит ViewModelStore, и если овнер помирает, то новый инстанс овнера должен получить старый инстанс стора, и отправляет clear(), если весь скоуп завершаетсч
ViewModelStore подвязан на application класс
A сама вьюмодель достается из viewModelStore
Вся логика хранения стора лежаит в активити/фрагменте
Кароче сложная темка, смесь коллекции, кеширования, синглтонов. Так вроде живёт там класс nonConfigurationInstances


Один запрос в сеть во viewModel

Чтобы при жц методах активити не дублировать запрос к беку (открытие, скрытие приложения), есть неск способов:
Есть viewmodel, но дергаем её извне во фрагменте в onStart(), и фрагмент сам пересоздается каждый раз при скрытии/раскрытии, а livedata к которой подвязаны данные на беке прожолжает жить тк так устроена. Изза чего дублирование шиммеров происходило.
Решение:
Накинул if во вьюмодели, делаю запрос к беку тока если livedata пуста, криво
Init в самой viewModel, типа она будет запускать сама себя, а снаружи её методы не дергаем. Bad practise, но наш выбор
Сделать в onCreate() проверку на наличие savedInstanceState, если он будет, значит активити была восстановлена (но тут момент, что стейт может быть, но вьюмодель уже мертва). Кароче при смене конфигураций и onStop() сейвится стейт и дергать вьюмодель имеет смысл только если все создаётся заново, с нуля, иначе юзаем лайвдату имеющуюся, неочевидно
Lazy field во вьюмодели, с фабрикой, сложно


Permissions

В runtime с 23 апи начали запрашиваться, а не при установке


ViewGroup extends View

Пакеты андроида


Livedata moments

Observer получает события только если он (активити) в состояниях started/resumed, в других случаях нет. А вот отправляет ли событие Observable хз, наверно нет.
Сколько раз пуляли данные, столько они и приходили в observer, даже те же самые


Activity lifecycle

onPause() частично видна юзеру
onStop() не видна
onDestroy() терминация идёт user/system
Те при сворачивании активити может повисеть в стопе, а потом restart сделать, если не будет прибита системой


Fragment backstack

Есть backstack приложения (активити), а есть фрагментов
Мы делаем replace и соотв заменяем фрагмент при открытии и скрытии активити с экрана
Соотв после activity onStop() дёргается фрагментский onDestroyView() и onCreateView(), те весь жц бегает
Изза этого извне дергается view model каждый раз, где дёргается метод запроса к беку, и шиммеры заодно, но тк change livedata не произошло, и данные те же, то апдейта списка не происходило. И когда восстанавливали бегал шиммер
Решение см в заметке Один запрос в сеть во viewmodel
Новый инстанс создаётся во фрагмент манагере и вёрстка подставляется в onCreate() те жить фрагмент начинает после этой точки, а картинка со связью жц акьивити и фрагмента она показывает кейсы, когда умирает например или рестартует активити


Ссылки на view в thread


Прихожу к решению как делать чтото

Ищу аналогию по проекту, смотрю если встречаются подобные паттерны, значит ок


Нельзя делать, тк поток может утечь при смене конфигурации


configurationChange()

Не только landscape portrait, но и показ клавы и смена языка


Custom components

Для них чтобы state сохранялся надо херачить override onSaveInstanceState, для стандартных компонентов, они делают это сами при наличии id в xml


SharedPrefs

Дисковое хранилище key value, похоже на saved state


App backstack

При сворачивании приложения создаётся иллюзия многозадачности, но по факту приложение может быть остановлено системой, если мы убрали его и открыли другое например.
При возврате к убитому ранее приложению данные должны быть подтянуты seamless для юзера, для этого юзается saved state например
Данные пишутся на диск и это позволяет переживать убитие процесса


savedInstanceState()

Если у активити был предыдущий стейт и она пересоздана, bundle будет not null
Механизм такой: если завершение активиьт не подразумевает пересоздания дергается метод finish(), и данные не сохраняются в bundle, иначе сохраняются.
Bundle переживает жц активити с помощью key value. В нем живут данные view например при config change
Bundle сериализация живёт на main thread
RestoreInstanceState сам проверяет наличие состояния, в отличие от bundle в onCreate()


Saving state

View state (id view нужен обязательно)
Saved state - тут не должно быть сложных типов данных
Variables
View model - можно сложные типы данных
Remote/file system


Application class lifecycle

Global класс инстанс которого живёт пока жив процесс, свои коллбеки, onLowMemory(), если процесс система хочет подчистить
Кейсы использования редкие, когда надо сделать чтоьл до создания первых активити, Статик методы для shared объектов


Завершения активити

User initiated
Нажатие back
Home и свайп
Нажатие up (appbar)
System initiated
Config change
Low memory
Способы пережить:
[Mem] ViewModel (не для system process kill)
[Disk] SavenInstanceState (умрёт только при back)
Сеть/disk (prefs)


Связь onSaveInstanceState() и параметра в методах жц активити

В onCreate(saveInstanceState: Bundle) идёт, а также в
Первый метод вызывается после onResume(), а также его аналог onRestoreInstanceState() перед onResume(), это по старому. По новому до onStop()
Не путать с bundle intent при передаче данных между экранами


ViewModel

Хитрая логика внутри: переживает пересоздание активити при смене конфигурации (не process kill, тогда состояние данных теряется и надо юзать в связке с onSaveInstanceState())
В случае vm данные живут в памяти только и данные живут во viewModelStore коллекции, где у каждой активиьи есть viewModelStoreOwner
На каждый новый инстанс активити подтягивается данные из viewModelStore


Fragment lifecycle

Нет restart, тупо от create до destroy
Следует за жц активити
https://basaransuleyman.medium.com/android-activity-lifecycle-and-fragment-lifecycle-states-and-method-descriptions-136efc3c2ff3


Activity и viewmodel

LifecycleOwner


Почему умирает активити при configuration changes

Для простоты, иначе пришлось бы хендлить layouts как то, запоминать состояния
Но можно onConfigurationChanged самому изъебнуться сделать


Update project

Develop делаем rebate кнопкой в студии сверху справа
После освежения девелопа, можно заребейзить фиче ветку, но лучше сделать это через меню git, далее параметр rebase'a develop.
Тем самым мы натянем посл коммиты нашей фичеветки (те её саму) на свежий корень девелопа
Далее при пуше будут лишние коммиты чужие отображаться, это ок
Также потом может быть конфликт, если свои изменения были на ремоте, и я их заребейзил в фиче ветку, и на тех же строчках уже новый код добавил, надо разруливать конфликты будет
Все это стреляет в ногу изза параллельного начала новой задачи и ведения пр по прошлой, где были нужные мне изменения, которые конфликтнут будущие. Типа выстрел себе в ногу из прошлого долетает.


Тестирование coroutines

Это своя ебка, детали:
Нужно тесты запускать из scope runTests {}, по аналогии с самим лаунчем
Также пришлось хитро подкидывать dispatcher


Design system

Научился работать в связке с Figma > DesignSystem components
Беру тип компонента из дизайна и иду в проект, там его нахожу, ес все хорошо, и читаю его атрибуты доступные, потом применяю в коде или xml


Android studio shelves

Удобна полка для каких то фишек, которые нужны самому, но не должны попасть в репу на ПР
Делается как коммит, stash/unstash, после чего эти изменения откладываются в сторонку, и их можно будет припрятать, а потом достать (сохранённый функционал).
Складыаал так моктрование ответа от бека
Сюда же git stash unstash
Работает отлично, шелвы студии больше понрав.
Возврат через rollback
Но лучше через changelist там переносим шелв в раздел shelf и все спрячется назад. Но файл с назв шелва задублируется


Ssl pinning

Механизм защиты клиента при взаимод с беком
Хардкодит гдето кусок сертификата либо его параметров
И к беку чужие клиенту не подрубятся


Build moments

Перед сборкой надо делать optimize imports по всему модулю, чтобы билд не упал изза кривого импорта


Убрать все импорты с директории

Директория: control+option+o


Mvi

По сути тот же mvvm, но с добавлением состояний в модель. Это из js пришло.
Кароче идея, чтобы модельки не данные отображали, а состояние. Типа для лучше консистентности
Sealed классы и вот это вот все. Классы которые имеют заранее известных потомков в компайл тайме.


Mvvm

Model это data + domain слои


Coordinator

Кароче сам по туториалам почти сделал до конца, оставалось только докрутить
contentScrim - color для abbparlayout
И флагами scrollflags поиграться scroll|exituntilcollapsed|snap


Верстка момент

Надо всегда делать не кастом, а сложную готовую верстку, как в других модулях, но выключать соотв флагом лишнюю функциональность, чем самому пытаться её повторить простым layout'ом


Idea/studio moments

Есть оказывается max tab cnt дефолтный, бля
Cmd и наведение стрелки на метод даст сигнатуру без доки


MaterialDesign Heights

Statusbar 24dp
AppBar 56dp


Transparent appBar

Вместе с statusBar
Можно сделать только с coordinatorLayout и collapsingToolbarLayout, на простом не удалось
Все делала тема, кроме цвета шрифта статусбара, он задавался через тему: windowLightStatusBar
Тема transparent sbol - toolbarTextColor, actionBarTheme (transparent), statusBarColor, oppositeTheme


CoordinatorLayout

Disable animation flag (collapsingLayout):
layout_scrollFlags: noScroll
Diasable shadow after disabling animation (appBarLayout):
stateListAnimator: @null


Эмулятор moments

Умеет лагнуть, там сверху полоса чёрная. Помогает удалить эмулятор и заново создать.
При дублировании номер эму сохраняется, что хорошо, алиасы целы
Надо чекбокс ставить, no frame при создании, типа менее красиво, но более надежно


Поиск по проекту

Double shift ищем следы использования кода
Далее нашли кнопкой + модуль, и в нем ищем xml: cmd shift f по директории с xml, находим нужное


ConstraintLayout last view height

Textview и imageview внутри constraintlayout делал там они не друг за другом отрисовывались, решение либо для картинки elevation 1 делать либо вложенный textview внутрь imageview вставлять. Кароче это ебаный костыль
Когда последняя вьюшка не хочет занимать всю высоту, надо ставить у неё не match_parent, а 0dp


Constraints moment

Можно кароче накидыаать компоненты без constraintov, потом палочку волшебную нажать и студия сама накидывает их


Круто анимированный layout

Используемый в многих страницах сбола, и который будет в нашем - coordinatorLayout
Он анимирует appbar и верхнюю часть


Фишки

Layout inspector - отображение развертки макетов в проекциях


Проект не собирается

Вкл выкл впн
Restart invalidate caches
Clean + rebuild
Gradlew problemTask rerun-Tasks
Rm rf cache.dir


Поиск наследников

Слева от интерфейса зеленая кнопка, покажет все реализации


Поиск нужных зависимостей в проекте

Кароч смотрим красное, далее через cmd и кликаем по нему и открываем нужный файл
Далее волшебный (+) и слева открывается модуль в директории, его название добавляем в impl dependencies


Static vs App lifecycle

Статики переживают активити lifecycle, и живут пока класс не будет выгружен, т.е. либо jvm shutdown произойдёт, либо process kill


Волшебная кнопка студия

Находит открытый файл на табке в структуре папок
(+) справа от выбора типа project/android


Интеграция Jira и Студии

Есть такой ахуинный функционал, Tools > contexts
Хоткей, для открытия тасок: opt + shift + N


Logging

Хз как дома, но в Сбере логи сыпались только в Logcat, в Run их не было
Делаем в Activity


Golden hint for errors Sbol

Назер удаляем папку build/gen
Либо проект


BuildConfig

Класс который создаётся, при добавлении в скрипт gradle в блок defaultConfig переменных. Они потом будут доступны в рантайме
У нас плагин switch box добавляет булевые константы из jsona походу


Кароче IBinder

Нужен для нормального взаимодействия компонентов и сервисов как в рамках одного процесса, типа данные в активити нормально передать, так и для межпроцессного взаимод
Делается через класс Binder, и bindService() для одного процесса
Либо через messenger и AIDL


Gradle modules

Есть 3 типа: android, library, java/kotlin
Первый создаёт отдельную версию приложения в проекте, которое запускается и билдится самостоятельно: юзкейс - типа про версия и фри версии
Library это будет подмодуль для основного приложения, его надо будет доподключать в build.gradle app уровня, юзкейс - impl фичи
Java/kotlin это api фичи, без андроид кода


Google drive пригар

Сука не даёт пошарить мою apk другим юзерам, пишет мол нужно провести проверку. Яндекс Диск for life.


TextView

Перенос текста тупо в строке "blabla\n bla bla"


Документация Android Studio

Надо в SDK manager ставить галку sources, скачивать


Foreground service

Android manifest не забываем добавлять пермишн
 Стартуем startForegorundService(intent), а не обычный
В самом сервисе в onStartCommand() вызываем метод включения foreground вариации startForeground()
Ещё может потребоваться ебочка в манифесте с exported=true для активити, у которой есть intent filter с категорией лаунчера


R strings Studio

Если не видит строки, надо проверить импорт, чтобы было не import android.R, а com.example.lesson26.R


App flavors

Это как build variants сущность, позволяет несколько типов приложений выпускать, типа free/pro/debug/release etc
У нас в проекте неск вариантов типа aloha beta base kav unsecure server mock
Bv задаются в build.gradle на уровне модуля
Pf на уровне всего app


Service start types

START_STICKY когда система прибъет сервис изза нехватки памяти, она же сама потом запустил его, когда она появится
START_NOT_STICKY нет


Remove modules AS

Делается через меню project structure


ApplicationId

В gradle задается. Уник ключ проекта в google play. Схож с структурой директорий проекта


Push / notification

Первый это remote communication
Второе это интернал из приложения


Модули

Есть gradle (они же студиевские). Нужны для удобства, и ускорения времени сборки. Каждый модуль отдельная приложуха обобщенная проектом
Есть dagger


Instrumentation test

Тест на андроиде
Pure jvm - локальный


Project build alias

gradlew sberb && ad install build_output && adv shell start splash


Jvm options

Задать размер heap initial -Xms
Максимальный -Хmх
Но по факту будет использоваться больше, там ещё плюс стек и ещё вспомогательная память
Также это для jvm самой которая запускается. Также для студии своя jvm, чтобы она сама работала


Настройка производительности студии

Выделить память для студии. Тут в help меню ставить значения, откроется файл vmoptions, и там будет значение как в префах. Но в последних почему то больше 4гб нельзя задать. А если руками найти файл, то там не такое значение
Удалить папку .idea
Работать через vpn - remote cache
Spotlight Exclude директорию проекта. Дир студии не удалось
Билд с команды


SwipeRefreshLayout

Работает чётко
Один коллбек onRefresh() и все работает
Только похерил разметку


No internet dialog

Чтобы не пустить дальше в приложение
Хитрый onShowListener
И setDismisaable(false)


Splashscreen

Много способов
Старый через другую активити и таймеры
Новый через SplashScreenApi (ебка с темами была аццкая)
Спрятать рассчет так и не удалось. Тупа после сплеша все заново начинается


Шиммеры (Facebook API)

Те самые placeholders, что грузятся моргая
Удобно, легко. Надо контролить процесс бекграунд работ самим, чтобы останавливать анимацию


Связь из activity to ViewModel

Через аргументы конструктора только видел способ


Dagger

Зависимости классов и создание объектов делает за нас


Kotlinx.serialization

Норм подход, работает хорошо, лучше чем moshi


Snackbar

Удобная штука для сообщений об ошибке. Больше никаких textView
Типа как тост, только побольше


ViewModel (class)

Либа удобная для создания viewModels
Служит для хранения данных view.
Знает жц компонентов, переживает смену конфигурации
Тут лежит Livedata
ViewModel это observable
А активити/фрагмент это observer они слушают изменения данных в livedata. Являются lifecycleOwner'ами для viewModel'и.


Mvvm

Как mvp только вместо presentera viewModel. Ссылки на vm у view нет, реализуется связь через databinding или обсервер (наш случай)
Для каждой активити свой vm
Нужен для разделения доменного слоя (данных, бизнес логики) от презентационго слоя
Также для переживания смены конфигурации


LiveData

Типа статик листа, который знает о жц компонентов приемников, куда можно подписываться в акьивити/фрагменте, и получать события из источника MutableLiveData<Object>
Работает только в состоянии stated / resumed
Лежит во ViewModel


RxJava

В общем есть подписчик и источник
Писать много, см пример дз 18_1
Observable, flowable, comparable, disposable...
Можно тредировать так задачи
subscribeOn() / observeOn()
.subscribe()


Implicit intent

На старт deeplinka - обработает dialog chooser


TextView render time

setText() - 1 msec


JSON serializations

Есть java Jackson
Есть Moshi для android
Есть java / kotlin jsonObject (native)
Есть kotlinx serialisation (native) // todo: попробовать потом


Fragment displacement

Кароче если разметка фрагмента больше исходного поля fragmentContainer, то оно просто обрежется нахер. Надо делать фрагмент с учётом родителя


ViewBinding

Удобный механизм, чтобы не клепать findViewById()
Для активити:
сначала xml делаем, потом поле класса типа xmlNameBinding, немного меняем inflating, и все поля хмл доступны из переменной
Для фрагментов:
На пару строк больше, чем в активити
Build gradle module: "viewBinding true"


Fragments

Можно создать viewContainer - fragmentContainerView из кода и добавить к текущей разметке LinearLayot снизу
rootView.addView(container)
Также инстанс фрагмента создаётся через newInstance в самом фрагменте
Данные передать внутрь можно через bundle - setArguments
Взаимодействие между фрагментами делать через acitivy implements interfaceApi


Animations

Тупой frame by frame
Есть valueAnimator, анимировали спидометр
Можно как из кода, так и из xml задавать
Есть способ для swipe&drap recycler framework: simpleItemTouchCallback
Там можно в getMovementFlag настроить что и как будет двигаться, а также onSwipe и onMove делать, то, что нужно


targetSDK, compileSDK, minSDK

Первый это для догоняния Latest Android version (типа он указывает фичи которые будут включены, permissions пример буду норм работать на версии до той, где появились). Runtime
Compile это версия api которая будет доступна при сборке
min это просто
Min < target < compile


Custom views 1

Надо наследоваться от view
Создавать styleable.xml с атрибутами для xml
Далее из темы иниц эту тему и деф значения
Можно прикрутить в тему/стиль
Осн метод override fun onDraw(canvas: Canvas): тут рисуем методами
drowLine(), drawCircle() drawText() etc
Так же есть onMeasure() тут надо настраивать, чтобы атрибуты match_parent, wrap_content работали и resizeить вьюху
invalidate() requestLayout() для перерисовки
Speedometer sample


Передать данные в recycler dynamically

Можно сделать одну верстку для разных адаптеров в recycler. Сложно но работает. По клику на итем recycler будет открываться новый recycler с теми данными которые передадим через ссылки и обработку в новой активити


Анимация смены позиции recycler

notifyItemMoved(oldIndex, newIndex)


Activity lifecycle

1. Сначала create(), start(), resume()
Запускаем вторую
1. OnPause()
2. Те же три метода
1. Stop(), destroy()
Назад
2. Pause
1. Create start resume
2. Stop, destroy


OnFocusChanged()

Передача id view при получении фокуса элемента - focusChangeListener().
Связать id элемента списка при нажатии - в холдер переместили focus listener, получаем id itemа через holder.adapterPosition().
Не смогли сделать onTextChangeListener() вызов метода. Получался focus loop
Передать флаг при нажатии на разнотипном списке можно в разных viewholder'aх. Передавать параметр в интерфейс листенера, потом снаружи его юзать в активити


Нюанс с focusChangeListener

Может почему-то возвращать -1 adapter.Position.


Get view id on touch inside recycler

Сделал чудом через holder.adapterPosition
В адаптере в onBindViewHolder() сделал focus listener на editText. Далее при нажатии выводил id


AStudio file header

Author + date
Делается через settings > editor > file and code templates > file header


RecyclerView not clickable

Если нет click listeners на элементы списка, то чтобы при задании itemBackground была анимация нажатия надо ещё clickable focusable true делать!


Adb file transfer moments:

adb devices
adb shell стартует
adb push pathPc pathDevice
adb pull pathDevice pathPc
Только не работает с опр директорией: /storage/sdcard0. Складывает файлы в меню emulated в проводнике (корень)


Intent launch mode

Есть разные режимы, чтобы открывалась одна активити один раз по нажатию, а не n раз
Всего 4. Адекватные первые 2


Deeplinks

Открывал чужие, методы см в yandex hackaton task
Создавал свои в сбере: intent filters задаются на хост/путь, далее можно через интент параметры из строки вытащить


Парсинг сложного JSON:

Retrofit и pojo class автоматом
Или вручную через JsonObject. Тут аккуратно, если нужны данные из вложенной структуры, надо несколько раз вызывать методы друг на друге: jsonArray.getJsonObject() для массива json или getJsonObject()


Image crop

Чтобы картинка сасно вставилась надо ей атрибут scaleType "centerCrop" делать


Sqlite

Даже чистые данные вставлялись не полностью, хз почему


Sigsegv ебучий

Или segmentation fault
Возникал при использовании room / sqlite. На больших (50к строк) данных, или корявых данных.
А также при использовании многа памяти. Помогло не дублировать загрузку каждый раз.


Splash screen

Так делается экран старта приложения, при загрузке контента
Делается темой или новой фичей


Image formats

Png без фона (без потерь качества), jpg с (шакалистый)
Webp оптимизированный, юзаем его. В 20 раз меньше места занимает, чем пнг


UI тесты

Можно повторять действия тестера
Надо чтобы фрагменты которые тестим, были на первом экране который открывается
Типа на main activity. Если нужен опр фрагмент, то он должен открываться по умолч из этой активити. Тогда espresso достучится до нужной view
Fragments отдельно только из Kotlina
И записать шаги реальные, потом повторить
!!! Ещё анимацию пришлось отключать на девайсе


Instrumental test

Руками создаём класс (ctrl alt t), в директории androidTest.
После делаем аннотацию @RunWith ... После он будет отображаться в идее как надо
В целом сложна ебка какая то. Другие кейсы кроме preferences хз как чекать


Android tests

Виды тестов в Android соотв папкам в Studio
instrumental - тесты с исп android классов
unit только plain Java
Ну и типы тестов в общем бывают
Unit
Integration
UI ручные нажатия (или из кода, эмуляция юзера в общем)


Activity lifecycle difs

OnCreate() вью на создана
OnStart() вью доступна для взаимодействия


OneSignal

Механизм типа Firebase, только настраивается сложнее, а работает надёжнее.
Позволяет слать пуши
Обрабатывать пуши своим handler'ом надо
Почему то не завелось вместе с Firebase, и вообще только с 5го раза
Тоже по мануалу, привязка приложения должна пройти при первой установке, ряд либ импортнуть, привязать Firebase акк к OneSignal акк. Но сам firebase настраивать на приложении не надо


Firebase CM

Тулза для аналитики и статистики пользования приложения юзерами, удобная штука
Настраивается по мануалу, gradle либы, кабинет и подвязка к приложению
Далее можно пуши слать оттуда на приложения, графики смотреть
Но пуши приходили не так уверенно, как с OneSignal
Говнистый момент - в доках не указано, но надо импортить зависимость firebase messaging, чтобы пуши приходили
Обработка пушей также своим handler'ом


Clean project AS

Build > clean project
Нужно, чтобы при изменении каких то конфигов, темповые файлы сборки обновились


Капризы MediaPlayer

Может кидать NPE для каких то файлов, причём формат один и тот же


View colors styles

(Xml) Button background color: чтобы не сьехали corner round etc, надо юзать backgroundTint, вместо background
(Xml) Стиль кнопок: делать через атрибут style, а не android:theme, только так будет корректно подтягиваться стиль, там углы и тд.
(Programn) Background color: делать через setBackgroundResourse(R.color.col1) Надо юзать вместо хардкодного setBackgorundColor (#abcfea)


В switch

Только подавать final static string, не final не подойдут


Branch from ide Git

Научился бранчевать из android studio, там vcs > branch new, так сделается копия текущего проекта, но в новой директории, затем при пуше там будет коммит не а мастер, а новую ветку, которая будет создана в удаленном репо. После пуша, она создастся.
После нужно будет сделать merge, если с фичей все ок, затем можно удалить фиче ветку. Она будет во вкладке pool requests
А ещё статки посещений можно смотреть, кто заходил, и граф коммитов, вкладка insights
Притянуть инфу в иде в проект с репы -


Теряется состояние fragment'a

При переключении bottom nav menu
Todo + зануление ссылок di


Если adapter не работает

Или ещё чтото, требующее context. То нужно хранить ссылку на fragmentActivity (получить из getActivity()), и через runOnUiThread() все запилить.
Делать через Context context не работает (c handler)


GitHub readme pics

Делается через ссылки <а> html, с ресайзом. Ну и сами картинки туда же где и readme надо сложить. Путь без слеша начинается


Момент с up / back

Кнопка стрелка назад имеет другое поведение, чем системный back. Чтобы она работала также, надо включать в манифесте launchMode = Singletop


Picasso

Удобная и легкая либа для загрузки картинок по url


Frameworks android:

Типа сам андроид это фреймворк на линуксом
А есть ещё более абстрактные:
Retrofit (сеть, над okhttp)
RxJava (threading, альтернатива corutines kotlin)
Room (бд над sqlite)


Room

Рабочий фреймворк, чтобы руками с sqlite не работать, все делает за нас.
Запросы в бд. Чтобы обернуть в rxjava, work case юзать room, а не сырую бд


Подход к разработке

Сначала говняшку на main activity лепим, потом уже архитектуры всякие mvc, mvp, mvvm, etc..


Асинхронные запросы

Что retrofit, rxjava, okhttp асе они делают либо синхр либо асинр запросы - первые сами тредим.ю, гемор. Вторые сами поток внутри создают. И ещё callback используют на ui треде, т.е удобно к интерфейсу можно обращаться


Функциональщина

Это лямбда выражения
Противостояние любимому императивному


RxJava

Типо асинхронный event механизм. Типа надстройка над Observable и threading
Запрос к бд или сеть можно сделать через нее
Делается легко надстройкой для retrofit: тип observable для интерфейса, параметр в билдер retrofita, и обработка запроса там цепочка методов, все


Retrofit

Довольно ебабельная либа для работы с сетью. Сложнее и функциональнее okhttp. Позволяет привязывать веб api к java interface api.
Создаётся объект из json а на сервисе json to pojo
Создаётся интерфейс с методами
Создаётся билдер синглтон с коллбеками
Магия происходит и можно в список объектов List<User> за один запрос к api сериализовать список json`а. Ничего руками getint и тд делать не надо, как в okhttp (при условии простого json, иначе все равно придётся, хоть и меньше)
Момент с pagination api раскурить потом todo


Нюанс fragmentContainerView

Если первый фрагмент не отображается, то нужно указать свойство name и полный путь к фрагменту в атрибутах fcv
А ещещ fcv отображает фрагмент уже с доступной ему области, т.е. меню снизу не кропается


getView()

Ещё один способ получить view из фрагмента (помимо getActivity(), getContext())
Так можно backgroundColor задать


Залочить landscape

В манифесте в активити: screenOrientation="portrait"


MinSDK

Задается в built gradle (module), там же, где и dependencies


Appcompat/Android platform

Какие то версии одного и того же


Имя приложения

Manifest > android:label="abc"
Package name лучше чтобы соответствовал


Themes / Styles

Style для views, вынесенные параметры
Theme для всего app, activity, поддерживает не только view, но и statusBar например
Можно задать для конкр view и подключить через атрибут styles


Serverless arch

Это aws облака


Chrome back forw

Alt + left/right


JSON over HTTP:

В java делали сериализацию/де объектов в/из json
Тут же по сети передавали в body объекта request
Ну и распарсили JSON до атрибутов (хардкодный метод)


TextView border

Делается через атрибут :background, куда устанавливается drawable shape (.xml)


Clear data / cache

Первый потрет файлы внутри типа data/data/files (картинки например)
А второе только темповые файлы


Файлы filesDir()

Persistent файлы - удаляются сами только при удалении приложения
Кэш это tmp файл (живут сколько указано в методах и тд)


Content provider

Ipc для обмена данными между изолированными процессами


Android resume

Под капотом Linux (process) + jvm (на каждое приложение)
Все работает на callbacks которые вызываются, когда юзер делает чтото с интерфейсом / девайсом
UI в xml
Есть внутренние механизмы для шаблонного взаимодействия типа contentprovider, broadcastreceiver, activities, intents, services
Если чтото переиспользовать то java наследование какого-то класса, или создание объекта требуемого класса


Data binding

Механизм, чтобы убрать findviewbyid
Используется viewModel
В grade добавлять надо


Material design

Смотрим так - XML: com.google.android.material.*


Storage

Есть getCacheDir() тот самый (оттуда удаляются файлы системой)
Есть просто getFileDir()
Есть бд sqlite
Есть assets (файлы внутри проекта типа)
Можно по сети качать
Есть preferences key value
Есть external storage (это не только microSD, а большая часть внутренней памяти). На нее нужен доступ


Adb moments:

Terminal: adb devices (выдаст номер девайса)
adb -s Номер shell
adb shell
Позволит коннектится к телефону и выполнять команды. Смотреть директории как на линухе ls. Но su без рута не сделать, поэтому много что ограничено


TextView hint

Можно сделать атрибут hint вместо default text удобно


GPS location

Делается либо через LocationManager()
Запрос прав
Периодическое обновление
Проброс юзера на окно включения gps
Либо play api


Permissions

Проверка наличия прав checkPermission()
Запрос прав requestPermission()
Обработка получения ввода юзера onRequestPermissionResult


Выравн элтов:

Надо вручную align между ними поставлять, иначе разъезжаются
Делать через align


TextView Selectable

В XML такой параметр нужно задать, чтобы данные можно было копировать из нее


Данные Android:

Internal/external storage
Key value storage (preferences)
SqLite db


Утечка памяти Android

Нюанс когда память не успевает очищаться, чтото её держит, когда она не нужна
Статик views не стоит делать, и еще рекомендации


TextView scrollable:

Оборачивается ScrollView. Вроде только один дочерний tw должен содержать.
После этого последний станет листаемым, если текст больше его размеров


Implicit intents

Action_sent можно юзать для обработки действия share
Можно сеттить вкладку открываемую в viewPager


Строки ресурсы в приложении

getResources().getString(R.string.btn_send)


Убрать view с экрана

progress at.setVisibility(invisible)
А если залочить нажимание, то setEnabled(false)


Куча

Отдельная структура данных (еще есть способ организации памяти такой, это другое), типа дерева, где максимум в корне, и она позволяет быстро доставать элемент с макс приоритетом
Делается на priorityQueue


Поменять состояние кнопки:

Так и не удалось setPressed() сделать из clickListenera другого


Toast не из UI

Надо делать workaround с getMainExecutor()


WorkManager

Лучше, чем JobSheduler, под собой содержит AlarmManager
Можно легко периодические задачи устанавливать


Drop down list

Назыв Spinner , можно ему ресурс в атрибут entries добавить, и значения будут протянуты из ресурсов строк, даже кода не понадобится


Пользование системных штук:

Context.getSystemService()
Тут и AlarmService
И Vibrator


Fragment listener

Нюанс - В onCreateView обязательно возвращать наш элемент view, а не super.blabla


BroadcastReceiver

Сущность для приёма интентов
Не забыть добавить в манифест
Используется для implicit intents, для чего в манифесте intent fliters задаются, а при отправке тип action интент устанавливается. Потом событие перезватывается всеми компонентами разных приложений, которые поддерживают данное действие
Может быть ещё explicit intent перехватываться


Notifications

Довольно просто делается через билдер и manager
Можно повесить обработку нажатия


AlarmManager

Точное время срабатывания событий, делается через pendingIntent и спец класс broadcastReceiver


Annotations

Не включаются при создании методов куча еболы типа @non null etc..


Layouts fragment

Если делать через создать fragment alt ins, то идея создаст его с говеным frameLayout, а нам нужен constraintLayout
Поэтому фрагменты руками создаём


BottomNavigationView

Меню снизу. Делается в конструкторе, клик листенер, атрибуты , отдельный xml на пункт меню. Selector на красивый выбор пункта меню
А вот переход между страницами реализуется через фрагменты


Toolbar

Toolbar это как actionBar (который системный сверху активити). Он же app bar
Menu это три точки справа сверху (overflow menu)
Ещё есть navigation bar снизу
И слева меню navigation drawer view гамбургер
Вкладки страниц


Планировщик задач

TimerTask java
SheduledExecutor java
======
SyncAdapter
Handler postAttime(), postDelayed()
AlarmManager, точный
JobSheduler, эффективный, но не точный
Самый актуальный WorkManager как я понял


Looper handler

Делаем задачи в отдельном потоке, Хуярим мессаджи в очередь, в хэндлере обрабатываем сообщения
Looper один для одного потока, реализует механизм очереди сообщений
Handler имеет связь с ui потоком, в нем обрабатываем views в зависимости от сообщений из worker тредов
Worker треды используют ссылку на handler
Типа тред не погибает при выполнении одной задачи, а живёт и ждёт
У каждого потока свой handler


Aidl binder

Какойто низкоуровневый интерфейс для взаимодействия компонентов в ос


IntentSevice

Типа сервис в отдельном потоке (одном фоновом)


Service & Thread

Первый может жить в фоне после закрытия приложения самого, но в ui потоке
Вторые закончатся как только приложение закроется, без фона, но потоки отдельные


Растяжение элементов

Если границы дочерних элементов неправильные, надо проверить родителя, и чтобы он был переменной ширины в виджете. Тогда все будет ок
Ну и позиционирование элементов один фиксируем жёстко слева например, а второй переменно крепим к первому. Тогда при повороте экрана все будет ровно
И ещё, все элементы нужно ровнять margina'ми, а не курсором.
Везде где можно match parent делать, и переменную ширину автозаполняющую


Установка одного атрибута дважды:

Обход проблемы в XML
Делается родительский контейнер, в нем свойство одного типа background цвет, а во внутреннем уже selectableitem при нажатии


Списки

Вообще по старому простые строковые делаются через arrayadapter
Если посложнее с картинками через baseadapter (getView)
Но по нормальному через recyclerview, уже с viewholder
Ещё одна оптимизация - метод на вью recyclerview hasfixedsize(true)


Стили res/layout

Если нужны не стандартные, то надо создавать xml с разметкой, и подтягивать в коде


Выровнять textview

Текст внутри элта по центру - атрибут gravity:center


Paddding/margin

Margin между элементами
Padding внутри


ViewHolder pattern

Inflater
Костыль для списков, чтобы не лагали, делается внутренним классом, хранит ссылки на textview/imageview, etc, так findviewbyid тяжеловесная операция
В recyclerview проще делается. В listview через gettag/settag


RecyclerView

Погружаются например 10 элементов из 100 в списке
Прокручиваем список, новые обьекты view создаются. Чтобы уменьшить расход памяти, часть первых элтов, которые уйдут из области видимости будут помечены dirty.
Потом когда прокручиваем, переиспользуются view. Типа данные просто заменяются, а обслуживает всего 13 views например, для 10 список.


Списки android

Есть adapterView(listView, GeidView etc), adapter
Есть recyclerView
Типа данные для отображения, список отображения listView и адаптер между ними


Okhttp

Синхронный вызов, в отдельном потоке делаем
Асинхронный сам в отдельном потоке делается


Если вылетает активити

Соддаем . java активити и xml ник, проверяем, что связь между ними выставлена в onCreate и xml нике.
Не забываем добавлять в манифест активити
Теги смотрим в xml
Ну и https/http резолвить руками надо если что при работе с сетью.


Builder pattern

Характерно создание объектов new Person.Builder()
.withName()
.withWeight()
Etc
Типа билдер класс вложен в наш основной, поэтому так. Юзается для удобства


Либы в android studio

Легко ставятся, просто в gradle dependencies тура строчку (из мавена можно)
Ну или через меню проектов


JSON andorid

Либо вручную через JsonObject (из коробки)
Либо GSON либа. Как Jackson примерно


Сеть android

Нужно делать в манифесте перимишн на сеть
Apache httpclient но это deprecated типа
Raw: httpUrlConnection (в jr похожее делали, загружая файл с urlа), либо Socket
Libs: okhttp, (retrofit)


Permissions

Dangerous нужен диалог с подтверждением пользователя. В runtime приложения
Usual автоматом даются
Если прав нет то будет securityException
Бывают к системным ресурсам, а бывают собственные пермишны для своих компонентов/других приложений


RxJava

Для stream обработки данных


Landscape

Поворачиваешь экран, тупо все коды заново отрабатывают onCreate и прочие
При открытии новой активити, и возврате к старой она начинает с начала onCreate все


Потоки Android

Можно как в java все 3 способа
Самый трушный инструмент Handler, но гемор
AsyncTask. Грязный код, не рекомендуется
=======
Looper есть сущность, MessageQueue
Отрисовывать UI только из UI main треда
View.post(runnable) на ui треде. Так из бэка можно на main передать результат
Activity.runOnUiThread(runnable) тоже как пост
Ещё есть Service но он не отдельный поток все равно. Просто невидимая операция. Но не долгая
Ещё IntentService (это с отдельным потоком)


Localization

Зависит от языка девайса
Для этого создаются отдельные папки res/values-fr/strings.xml, под каждую локаль


Android system

По сути линух
Каждое приложение это отдельный процесс, отдельный юзер, отдельная jvm, отдельные права на диск
Каждое приложение свой отдельный раздел памяти
Пользовательские разрешение


SaveInstanceState

Сохранение легковесное содержимого активити в map
Делается переменная константа STATE = "playerState"
И потом сохраняется saveInsState.putInt(STATE, curState)
Типа key сохраняем в переменную такой подход
Он же используется для intent


UI

TextView текст label
EditText поле ввода
Button кнопка
Фрагмент типа подмножество активити


Layots

Есть night/day ui
Есть portrait/labdscape ui
Есть mobile/tablet ui


Создание других экранов

Делается не в onCreate в mainActivity, а отдельной функцией. Потом эта функция прокручивается к onClick какой нибудь кнопке.
В маин все интенты создаются и put
В вызываемой активити вытаскиваются get


Custom activity:

Делается через no activity. До этого было Empty activity


Start new activity

Или новый экран, делается через интенты


Обработка кнопки:

Можно руками листенер делать, а можно сделать сначала заглушку метода, а потом в атрибутах (в дизайне) кнопки поставить в onClick созданный метод


Diff size верстка:

Надо делать так, чтобы элемент занимал асе свободное простанство. Это достигается за счет match constraint и группировки компонентов horizontal chain'омй
Ещё можно элементы относительно не краев, а других элементов


Strings android

Нужно не хардкодить строки в параметрах элементов, а выносить в res strings. Там они будут классно лежать, и по ссылке можно будет их юзать
Это можно сделать в строках > translation editor


Окна в приложениях

Это классы активити
Хотим открыть из одного другое, толкаем интент с нужным классом активити, и стартуем его


Intent

Это какая то абстрактная операция, которую надо осуществить


Потоки

Все действия в ui потоки делать отдельно, в background. Не в методах lifecycle activity


Activity data restore

1mb max bundle size
Тяжёлое в бд, а лёгкое можно


Activity lifecycle

При нажатии домой, состояние сохраняется, послет возврата (foreground) данные на месте должны быть (в память, из памяти)
onResume()/onPause()
При назад много раз, backstack приложения очищается и оно закрывается, состояние не сохраняется (сохранять на диск)
OnStop()
Также может закрыться если приложение в background (не на экране) и не хватает памяти


Android nuance

Все асинхронное, на коллбеках
Мы лишь говорим, чтобы чтото запустилось, а не запускаем


Эмулятор/Реал девайс:

Надо относительно экрана все выравнивать симметрично, слева справа, сверху, снизу. А не в 2х осях. Иначе съезжает на девайсе с другим экраном


Положение view

Чтобы закреплялись, нужно делать constraint со всех 4 сторон кружочком
Иначе только в дизайне будет ровно, а в рантайме криво


Android studio shortcuts:

все как в идее +
Alt + shift + left/right вкладки design, code


Переносимость

Работает на любом девайсе с min sdk прописанным, и на target
Все элты должны относительно поставлены быть


Density pixel (dp)

Ppi= sqrt(wid^2 + hei^2)/diag, а можно тупа длину в пискелах по горизонтали поделить на длину экрана в дюймах и получить примерное значение(по ширине примерно такое же будет)
100px!=100dp
Виртуальный пиксель для среднеплотных экранов (160dp). На ноуте 100ppi, херовый экран
На низкоплотном экране картинка уедет, станет огромной, эту пробл как раз решает dp
Dpi dots per inch
Ppi pixels per inch
Px = dp * (dpi / 160)
Говорим 16dp подразумеваем, что на таком стандартном экране длина определённая будет (пр.16 пикселов - 2.5мм). Для каждого нового экрана нужен будет пересчёт с учётом его плотности пикселей.есть пример в доках, см density. Для высоких разрешений он там захардкожен типа 0.75, 1, 1.5, 2
Экраны 2340х1080 высота на ширину


Aos

View это сущности типа текстового поля, картинки и тд. Могут быть сгруппированы в ViewGroup (пр. Layout, ConstrLayout)
Каждому экрану приложения свой activity класс с логикой + свой activity xmlник. На каждый xmlник свои layouts вставляются, в них - views
Локализации делаются через strings класс


Apk build

Build > build apk
Bundle типа apk для публикаций
Ещё можно apk analyze чето посмотреть там декомпилировать сорс


ADB

adb logcat
adb shell (можно как в линксе файловую систему дрочить, но нужен рут на мобиле)
adb push/pull
run-as com.domain.app перейти в директорию (data) с приложением
adb shell monkey -p com.ex.app -c android.intent.category.LAUNCHER 1 запуск приложения из консоли


Android studio

Простой hello world заработал, так ахуенно! Надо чтобы был включён debug mode на девайсе.
Можно на эмуляторе тестить, а можно на реальном.
На последнем, из IDE устанавливается приложение на устройство, запускается, и останавливается. Также какие то логи пишутся в консоль


Android

Manifest.xml структура
MainActivity.java логика экрана
activity_main.xml интерфейс экрана (макета, layout)
Приложение состоит из Activity классов-экранов
View это XML ники


Callbacks

Код который вызывается асинхронно, когда будет получен результат. Некий объект который будет вызван, когда функция в другом потоке отработает.
Коллбеки от системы при создании компонентов, не напрямую вызываем, а события от ОС.
Позволяют быть уверенными, что опр код не начнёт исполнение до того момента, пока другой код не завершит исполнение
Пример с JS там одна функция начинала выполнятстся раньше той, что была выше её в коде, но времяемкая


Xml

Если в тегах есть вложенные теги другие, то первый должен быть парным <...> абс </...>
Если нет, то может быть непарным < ... />
